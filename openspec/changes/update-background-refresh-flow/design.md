## 背景
- `auto_sync_completed` 即便在窗口隐藏时仍会调用 `load_config()` 与 `update_statistics()`，导致整棵控件树被重建、过滤逻辑再次执行。
- 其他后台入口（自动同步定时器、最小化时触发的同步等）同样复用这套 UI 路径，名义上的“后台刷新”依旧与前台渲染争抢资源。
- 配置子系统已经具备磁盘缓存与轻量级内存缓存（`get_cached_config`），因此我们可以只更新数据而暂不渲染。

## 目标 / 非目标
- 目标：
  - 在 UI 隐藏时，将后台刷新结果安全写入磁盘与内存缓存，而不触碰 Qt 控件。
  - 确保启动器被重新唤起时，能一次性展示最新数据，且延迟最小。
  - 在窗口可见时仍保持即时刷新，用户发起的操作要迅速反馈。
- 非目标：
  - 重构历史/同步服务自身的逻辑。
  - 新增用户可见的后台刷新指示（如角标/Toast）；如后续有需求再讨论。

## 方案决策
1. **延迟刷新标记**：新增 `self._pending_ui_refresh`（布尔）与 `self._pending_config_snapshot`（字典+时间戳）。后台加载成功后只更新这些字段，不调用 `update_ui_with_config`。
2. **后台写入辅助函数**：例如 `apply_background_config(config_data, source)`，负责保存配置、更新历史、刷新缓存并设置待刷新标记，保证所有后台入口统一。
3. **恢复钩子**：在 `showEvent` 等“重新可见”入口中，先检查待刷新标记；若存在则从快照或磁盘加载数据，执行 `update_ui_with_config`，完成后清除标记再处理焦点逻辑。
4. **多次刷新合并**：每次后台写入都会覆盖上一份快照，而不是排队多个渲染。时间戳/版本号可用于日志并帮助在中途变为可见时丢弃旧数据。
5. **观测与日志**：记录延迟刷新被创建/消费的日志（及合并次数），方便性能排查。

## 风险与权衡
- **快照陈旧**：若用户在后台仍写入时打开窗口，需要确保助手在写入完成后才设置待刷新标记，否则 UI 可能加载到半成品。缓解：只在写入完成、缓存更新后才标记。
- **遗漏刷新**：若渲染完后忘记清理标记，会导致每次显示都重新刷新。缓解：在恢复钩子中集中清理。
- **线程安全**：后台 worker 通过 Qt signal 把结果发送到主线程，应继续在 UI 线程执行 helper，避免与 `load_config` 竞争。

## 迁移步骤
1. 引入后台助手与待刷新状态（暂不改变行为）。
2. 改造后台完成回调，改用助手。
3. 在 show/hide 恢复路径上应用待刷新逻辑。
4. 增加日志/测试并删除冗余的隐藏窗口 `load_config` 调用。

## 未决问题
- 是否需要在重新显示前给用户提示“已获取新数据”？当前不需要，可在 UX 评审后再考虑。
